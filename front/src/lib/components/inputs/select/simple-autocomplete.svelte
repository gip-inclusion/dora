<!--
  Initialy forked from
  https://github.com/pstanoev/simple-svelte-autocomplete/blob/2de0d7618b37192ec1ca47bbe4ffd47477b38792/src/SimpleAutocomplete.svelte
-->
<script lang="ts">
  // TODO: lint this file properly
  /* eslint-disable */
  import CheckboxMark from "$lib/components/display/checkbox-mark.svelte";
  import { checkIcon, closeCircleIcon } from "$lib/icons";
  import { clickOutside } from "$lib/utils/misc";
  import { formatErrors } from "$lib/validation/validation";
  import { onMount } from "svelte";

  // --- Internal State ----
  const uniqueId = `sautocomplete-${Math.floor(Math.random() * 1000)}`;

  interface Props {
    // the list of items the user can select from
    items?: any;
    // a list of items values that the user can not remove (ex: structure national labels)
    fixedItemsValues?: string[];
    // function to use to get all items (alternative to providing items)
    searchFunction?: ((searchText: string) => Promise<any[]>) | undefined;
    textCleanFunction?: any;
    // events
    onblur?: (evt: FocusEvent) => void;
    onChange?: any;
    onFocus?: any;
    // Behaviour properties
    selectFirstIfEmpty?: boolean;
    minCharactersToSearch?: number;
    maxItemsToShowInList?: number;
    multiple?: boolean;
    // Workaround for https://github.com/sveltejs/svelte/issues/5604
    hasPrependSlot?: boolean;
    hasAppendSlot?: boolean;
    hasCustomContentSlot?: boolean;
    // ignores the accents when matching items
    ignoreAccents?: boolean;
    // all the input keywords should be matched in the item keywords
    matchAllKeywords?: boolean;
    // sorts the items by the number of matching keywords
    sortByMatchedKeywords?: boolean;
    // allow users to use a custom item filter function
    itemFilterFunction?: any;
    // allow users to use a custom item sort function
    itemSortFunction?: any;
    // do not allow re-selection after initial selection
    lock?: boolean;
    // delay to wait after a keypress to search for new items
    delay?: number;
    // true to perform local filtering of items, even if searchFunction is provided
    localFiltering?: boolean;

    // UI properties

    // option to hide the dropdown arrow
    hideArrow?: boolean;
    // option to show clear selection button
    showClear?: boolean;
    // option to show loading indicator when the async function is executed
    showLoadingIndicator?: boolean;
    // text displayed when no items match the input text
    noResultsText?: string;
    // text displayed when async data is being loaded
    loadingText?: string;
    // the text displayed when no option is selected
    placeholder?: string;
    // the text displayed when at least one option is selected
    placeholderMulti?: string;
    // apply a className to the control
    className?: string;

    // HTML input UI properties

    // apply a className to the input control
    inputClassName?: string;
    // apply a id to the input control
    inputId: string;
    // generate an HTML input with this name
    name?: any;
    // generate a <select> tag that holds the value
    selectName?: any;
    // apply a id to the <select>
    selectId?: any;
    // add the title to the HTML input
    title?: any;
    // enable the html5 autocompletion to the HTML input
    html5autocomplete?: boolean;
    // make the input readonly
    readonly?: boolean;
    // apply a className to the dropdown div
    dropdownClassName?: string;
    // adds the disabled tag to the HTML input and tag deletion
    disabled?: boolean;
    errorMessages?: string[];

    // --- Public State ----

    // selected item state
    value?: any;
    initialValue?: any;

    text?: string;
    prepend?: import("svelte").Snippet;
    itemContent?: import("svelte").Snippet<[any]>;
    append?: import("svelte").Snippet;
  }

  let {
    items = $bindable([]),
    fixedItemsValues = [],
    searchFunction = undefined,
    textCleanFunction = function (userEnteredText) {
      return userEnteredText;
    },
    onblur = undefined,
    onChange = function (_newValue) {},
    onFocus = function () {},
    selectFirstIfEmpty = false,
    minCharactersToSearch = 1,
    maxItemsToShowInList = 0,
    multiple = false,
    hasPrependSlot = false,
    hasAppendSlot = false,
    hasCustomContentSlot = false,
    ignoreAccents = true,
    matchAllKeywords = true,
    sortByMatchedKeywords = false,
    itemFilterFunction = undefined,
    itemSortFunction = undefined,
    lock = false,
    delay = 0,
    localFiltering = true,
    hideArrow = false,
    showClear = true,
    showLoadingIndicator = false,
    noResultsText = "Aucun résultat",
    loadingText = "Chargement des résultats…",
    placeholder = "",
    placeholderMulti = "",
    className = "",
    inputClassName = "",
    inputId,
    name = undefined,
    selectName = undefined,
    selectId = undefined,
    title = undefined,
    html5autocomplete = false,
    readonly = false,
    dropdownClassName = "",
    disabled = false,
    errorMessages = [],
    value = $bindable(undefined),
    initialValue = undefined,
    text = $bindable(""),
    prepend,
    itemContent,
    append,
  }: Props = $props();

  // HTML elements
  let input: HTMLInputElement | undefined = $state();
  let list: HTMLDivElement | undefined = $state();

  // UI state
  let opened = $state(false);
  let loading = $state(false);

  let highlightIndex = $state(-1);

  let filteredTextLength = 0;

  // view model
  let filteredListItems: any[] = $state([]);

  // requests/responses counters
  let lastRequestId = 0;
  let lastResponseId = 0;

  // other state
  let inputDelayTimeout;
  let showList = $state(false);

  // -- Reactivity --

  function getLabelForValue(val) {
    const item = items.find((i) => i.value === val);
    return item?.label;
  }

  function isFixedItem(val) {
    const fixedItemValue = fixedItemsValues.find(
      (fixedValue) => fixedValue === val
    );
    return !!fixedItemValue;
  }

  function updateValue(newValue) {
    if (newValue) {
      const newText = multiple ? "" : getLabelForValue(newValue);
      if (text !== newText) {
        text = newText;
      }
      value = newValue;
      onChange(newValue);
    } else if (initialValue && text !== initialValue) {
      text = initialValue;
    }
    if (!multiple) {
      close();
    }
  }

  onMount(() => {
    if (value && !text) {
      text = getLabelForValue(value);
    }
  });

  $effect(() => {
    // Si text est vide et qu'on est en sélection simple, on réinitialise la valeur
    if (!multiple && !text) {
      updateValue(undefined);
    }
  });

  let listItems: any[] = $derived(prepareListItems(items));

  let clearable = $derived(showClear && (lock || multiple) && value);

  // --- Functions ---

  function safeKeywordsFunction(item) {
    const keywords = item?.label;
    let result = keywords;
    result = result.toLowerCase().trim();
    if (ignoreAccents) {
      result = removeAccents(result);
    }
    return result;
  }

  function prepareListItems(items: any[]) {
    if (!Array.isArray(items) || items.length === 0) {
      return [];
    }

    let selectableItems;
    if (fixedItemsValues && fixedItemsValues.length > 0) {
      selectableItems = items.filter(
        (item) =>
          !fixedItemsValues.find((fixedValue) => fixedValue === item.value)
      );
    } else {
      selectableItems = items;
    }

    return selectableItems.map(getListItem);
  }

  function getListItem(item) {
    return {
      value: item.value,
      // keywords representation of the item
      keywords: safeKeywordsFunction(item),
      // item label
      label: item.label,
      // store reference to the origial item
      item,
    };
  }

  function prepareUserEnteredText(userEnteredText) {
    if (userEnteredText === undefined || userEnteredText === null) {
      return "";
    }

    const textFiltered = userEnteredText
      .replace(/[&/\\#,+()$~%.'":*?<>{}]/gu, " ")
      .trim();

    filteredTextLength = textFiltered.length;

    if (minCharactersToSearch > 1) {
      if (filteredTextLength < minCharactersToSearch) {
        return "";
      }
    }

    const cleanUserEnteredText = textCleanFunction(textFiltered);
    const textFilteredLowerCase = cleanUserEnteredText.toLowerCase().trim();

    return textFilteredLowerCase;
  }

  function numberOfMatches(listItem, searchWords) {
    if (!listItem) {
      return 0;
    }

    const itemKeywords = listItem.keywords;

    let matches = 0;
    searchWords.forEach((searchWord) => {
      if (itemKeywords.includes(searchWord)) {
        matches++;
      }
    });

    return matches;
  }

  async function search() {
    const textFiltered = prepareUserEnteredText(text);

    if (textFiltered === "") {
      if (searchFunction) {
        // we will need to rerun the search
        items = [];
      } else {
        filteredListItems = listItems;
      }

      return;
    }

    if (!searchFunction) {
      processListItems(textFiltered);
    }

    // external search which provides items
    else {
      lastRequestId += 1;
      const currentRequestId = lastRequestId;
      loading = true;

      // searchFunction is a generator
      if (searchFunction.constructor.name === "AsyncGeneratorFunction") {
        for await (const chunk of await searchFunction(textFiltered)) {
          // a chunk of an old response: throw it away
          if (currentRequestId < lastResponseId) {
            return false;
          }

          // a chunk for a new response: reset the item list
          if (currentRequestId > lastResponseId) {
            items = [];
          }

          lastResponseId = currentRequestId;
          items = [...items, ...chunk];
          processListItems(textFiltered);
        }

        // there was nothing in the chunk
        if (lastResponseId < currentRequestId) {
          lastResponseId = currentRequestId;
          items = [];
          processListItems(textFiltered);
        }
      }

      // searchFunction is a regular function
      else {
        const result = await searchFunction(textFiltered);

        // If a response to a newer request has been received
        // while responses to this request were being loaded,
        // then we can just throw away this outdated results.
        if (currentRequestId < lastResponseId) {
          return false;
        }

        lastResponseId = currentRequestId;
        items = result;
        processListItems(textFiltered);
      }

      loading = false;
    }
  }

  function defaultItemFilterFunction(listItem, searchWords) {
    const matches = numberOfMatches(listItem, searchWords);
    if (matchAllKeywords) {
      return matches >= searchWords.length;
    }
    return matches > 0;
  }

  function defaultItemSortFunction(obj1, obj2, searchWords) {
    return (
      numberOfMatches(obj2, searchWords) - numberOfMatches(obj1, searchWords)
    );
  }

  function processListItems(textFiltered) {
    // cleans, filters, orders, and highlights the list items
    prepareListItems(items);

    // local search
    let tempfilteredListItems;
    if (localFiltering) {
      let searchWords;
      if (textFiltered) {
        searchWords = textFiltered;
        if (ignoreAccents) {
          searchWords = removeAccents(searchWords);
        }
        searchWords = searchWords.split(" ");
      }

      if (itemFilterFunction) {
        tempfilteredListItems = listItems.filter((item) =>
          itemFilterFunction(item, searchWords)
        );
      } else {
        tempfilteredListItems = listItems.filter((item) =>
          defaultItemFilterFunction(item, searchWords)
        );
      }

      if (sortByMatchedKeywords) {
        if (itemSortFunction) {
          tempfilteredListItems = tempfilteredListItems.sort((item1, item2) =>
            itemSortFunction(item1, item2, searchWords)
          );
        } else {
          tempfilteredListItems = tempfilteredListItems.sort((item1, item2) =>
            defaultItemSortFunction(item1, item2, searchWords)
          );
        }
      }
    } else {
      tempfilteredListItems = listItems;
    }

    const hlfilter = highlightFilter(textFiltered, ["label"]);
    const filteredListItemsHighlighted = tempfilteredListItems.map(hlfilter);

    filteredListItems = filteredListItemsHighlighted;

    return true;
  }

  function selectListItem(newValue) {
    // simple selection
    if (!multiple) {
      updateValue(newValue);
    }
    // first selection of multiple ones
    else if (!value) {
      updateValue([newValue]);
    }
    // selecting something already selected => unselect it
    else if (value.includes(newValue)) {
      updateValue(value.filter((i) => i !== newValue));
    }
    // adds the element to the selection
    else {
      updateValue([...value, newValue]);
    }

    return true;
  }

  function selectItem() {
    if (filteredListItems.length && highlightIndex >= 0) {
      const listItem = filteredListItems[highlightIndex];
      if (selectListItem(listItem.value)) {
        close();
        if (multiple) {
          input?.focus();
        }
      }
    }
  }

  function up() {
    if (highlightIndex > 0) highlightIndex--;
    highlight();
  }

  function down() {
    if (highlightIndex < filteredListItems.length - 1) highlightIndex++;
    highlight();
  }

  function highlight() {
    const query = ".selected";

    const el = list && list.querySelector(query);
    if (el) {
      if (typeof (el as any).scrollIntoViewIfNeeded === "function") {
        (el as any).scrollIntoViewIfNeeded();
      }
    }
  }

  function onListItemClick(listItem) {
    if (selectListItem(listItem.value)) {
      close();
      if (multiple) {
        input?.focus();
      }
    }
  }

  function onDocumentClick(e) {
    if (e.target.closest(`.${uniqueId}`)) {
      // resetListToAllItemsAndOpen();
      highlight();
    }
  }

  function onKeyDown(e) {
    let key = e.key;
    if (key === "Tab" && e.shiftKey) key = "ShiftTab";
    const fnmap = {
      Tab: opened ? down.bind(this) : null,
      ShiftTab: opened ? up.bind(this) : null,
      ArrowDown: down.bind(this),
      ArrowUp: up.bind(this),
      Escape: onEsc.bind(this),
      Backspace:
        multiple && value && value.length && !text
          ? onBackspace.bind(this)
          : null,
    };
    const fn = fnmap[key];
    if (typeof fn === "function") {
      e.preventDefault();
      fn(e);
    }
  }

  function onKeyPress(e) {
    if (e.key === "Enter") {
      e.preventDefault();
      if (opened) {
        onEnter();
      } else {
        open();
      }
    }
  }

  function onEnter() {
    selectItem();
  }

  function onInput(e) {
    text = e.target.value;
    if (inputDelayTimeout) {
      clearTimeout(inputDelayTimeout);
    }

    if (delay) {
      inputDelayTimeout = setTimeout(processInput, delay);
    } else {
      processInput();
    }
  }

  function unselectItem(tag) {
    if (disabled || readonly) return;

    updateValue(value.filter((i) => i !== tag));
    input?.focus();
  }

  async function processInput() {
    await search();
    highlightIndex = 0;
    open();
  }

  function onInputClick() {
    resetListToAllItemsAndOpen();
  }

  function onEsc(e) {
    if (opened) {
      e.stopPropagation();

      input?.focus();
      close();
    }
  }

  function onBackspace(_e) {
    unselectItem(value[value.length - 1]);
  }

  function onFocusInternal() {
    onFocus();

    resetListToAllItemsAndOpen();
  }

  function resetListToAllItemsAndOpen() {
    filteredListItems = listItems;

    // When an async component is initialized, the item list
    // must be loaded when the input is focused.
    if (!listItems.length && value && searchFunction) {
      search();
    }
    open();

    // find selected item
    if (value) {
      for (let i = 0; i < listItems.length; i++) {
        const listItem = listItems[i];
        if (typeof listItem === "undefined") {
          continue;
        }

        if (value === listItem.value) {
          highlightIndex = i;

          highlight();
          break;
        }
      }
    }
  }

  function open() {
    // check if the search text has more than the min chars required
    showList =
      (minCharactersToSearch === 1 ||
        (minCharactersToSearch > 1 &&
          filteredTextLength >= minCharactersToSearch)) &&
      ((items && items.length > 0) || filteredTextLength > 0);

    if (!hasPrependSlot && !hasAppendSlot && !showList) {
      return;
    }

    opened = true;
  }

  function close() {
    opened = false;
    loading = false;

    if (!text && selectFirstIfEmpty) {
      selectItem();
    }
  }

  function clear() {
    updateValue(multiple ? [] : undefined);
    text = "";

    setTimeout(() => {
      input?.focus();
      close();
    });
  }

  export function highlightFilter(keywords, fields) {
    keywords = keywords.split(/\s+/gu);
    return (item) => {
      const newItem = Object.assign({ highlighted: {} }, item);
      if (fields) {
        fields.forEach((field) => {
          if (newItem[field] && !newItem.highlighted[field]) {
            newItem.highlighted[field] = newItem[field];
          }
          if (newItem.highlighted[field]) {
            keywords.forEach((keyword) => {
              const keywordPattern = ignoreAccents
                ? makeAccentInsensitivePattern(removeAccents(keyword))
                : keyword;
              const reg = new RegExp(`(${keywordPattern})`, "igu");
              newItem.highlighted[field] = newItem.highlighted[field].replace(
                reg,
                "<b>$1</b>"
              );
            });
          }
        });
      }
      return newItem;
    };
  }

  function removeAccents(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/gu, "");
  }

  /**
   * Creates a RegExp that matches the words in the search string.
   * Case and accent insensitive @param search_string
   * @param searchString
   *.
   */
  function makeAccentInsensitivePattern(searchString) {
    const accented = {
      A: "[Aa\xaa\xc0-\xc5\xe0-\xe5\u0100-\u0105\u01cd\u01ce\u0200-\u0203\u0226\u0227\u1d2c\u1d43\u1e00\u1e01\u1e9a\u1ea0-\u1ea3\u2090\u2100\u2101\u213b\u249c\u24b6\u24d0\u3371-\u3374\u3380-\u3384\u3388\u3389\u33a9-\u33af\u33c2\u33ca\u33df\u33ff\uff21\uff41]",
      B: "[Bb\u1d2e\u1d47\u1e02-\u1e07\u212c\u249d\u24b7\u24d1\u3374\u3385-\u3387\u33c3\u33c8\u33d4\u33dd\uff22\uff42]",
      C: "[Cc\xc7\xe7\u0106-\u010d\u1d9c\u2100\u2102\u2103\u2105\u2106\u212d\u216d\u217d\u249e\u24b8\u24d2\u3376\u3388\u3389\u339d\u33a0\u33a4\u33c4-\u33c7\uff23\uff43]",
      D: "[Dd\u010e\u010f\u01c4-\u01c6\u01f1-\u01f3\u1d30\u1d48\u1e0a-\u1e13\u2145\u2146\u216e\u217e\u249f\u24b9\u24d3\u32cf\u3372\u3377-\u3379\u3397\u33ad-\u33af\u33c5\u33c8\uff24\uff44]",
      E: "[Ee\xc8-\xcb\xe8-\xeb\u0112-\u011b\u0204-\u0207\u0228\u0229\u1d31\u1d49\u1e18-\u1e1b\u1eb8-\u1ebd\u2091\u2121\u212f\u2130\u2147\u24a0\u24ba\u24d4\u3250\u32cd\u32ce\uff25\uff45]",
      F: "[Ff\u1da0\u1e1e\u1e1f\u2109\u2131\u213b\u24a1\u24bb\u24d5\u338a-\u338c\u3399\ufb00-\ufb04\uff26\uff46]",
      G: "[Gg\u011c-\u0123\u01e6\u01e7\u01f4\u01f5\u1d33\u1d4d\u1e20\u1e21\u210a\u24a2\u24bc\u24d6\u32cc\u32cd\u3387\u338d-\u338f\u3393\u33ac\u33c6\u33c9\u33d2\u33ff\uff27\uff47]",
      H: "[Hh\u0124\u0125\u021e\u021f\u02b0\u1d34\u1e22-\u1e2b\u1e96\u210b-\u210e\u24a3\u24bd\u24d7\u32cc\u3371\u3390-\u3394\u33ca\u33cb\u33d7\uff28\uff48]",
      I: "[Ii\xcc-\xcf\xec-\xef\u0128-\u0130\u0132\u0133\u01cf\u01d0\u0208-\u020b\u1d35\u1d62\u1e2c\u1e2d\u1ec8-\u1ecb\u2071\u2110\u2111\u2139\u2148\u2160-\u2163\u2165-\u2168\u216a\u216b\u2170-\u2173\u2175-\u2178\u217a\u217b\u24a4\u24be\u24d8\u337a\u33cc\u33d5\ufb01\ufb03\uff29\uff49]",
      J: "[Jj\u0132-\u0135\u01c7-\u01cc\u01f0\u02b2\u1d36\u2149\u24a5\u24bf\u24d9\u2c7c\uff2a\uff4a]",
      K: "[Kk\u0136\u0137\u01e8\u01e9\u1d37\u1d4f\u1e30-\u1e35\u212a\u24a6\u24c0\u24da\u3384\u3385\u3389\u338f\u3391\u3398\u339e\u33a2\u33a6\u33aa\u33b8\u33be\u33c0\u33c6\u33cd-\u33cf\uff2b\uff4b]",
      L: "[Ll\u0139-\u0140\u01c7-\u01c9\u02e1\u1d38\u1e36\u1e37\u1e3a-\u1e3d\u2112\u2113\u2121\u216c\u217c\u24a7\u24c1\u24db\u32cf\u3388\u3389\u33d0-\u33d3\u33d5\u33d6\u33ff\ufb02\ufb04\uff2c\uff4c]",
      M: "[Mm\u1d39\u1d50\u1e3e-\u1e43\u2120\u2122\u2133\u216f\u217f\u24a8\u24c2\u24dc\u3377-\u3379\u3383\u3386\u338e\u3392\u3396\u3399-\u33a8\u33ab\u33b3\u33b7\u33b9\u33bd\u33bf\u33c1\u33c2\u33ce\u33d0\u33d4-\u33d6\u33d8\u33d9\u33de\u33df\uff2d\uff4d]",
      N: "[Nn\xd1\xf1\u0143-\u0149\u01ca-\u01cc\u01f8\u01f9\u1d3a\u1e44-\u1e4b\u207f\u2115\u2116\u24a9\u24c3\u24dd\u3381\u338b\u339a\u33b1\u33b5\u33bb\u33cc\u33d1\uff2e\uff4e]",
      O: "[Oo\xba\xd2-\xd6\xf2-\xf6\u014c-\u0151\u01a0\u01a1\u01d1\u01d2\u01ea\u01eb\u020c-\u020f\u022e\u022f\u1d3c\u1d52\u1ecc-\u1ecf\u2092\u2105\u2116\u2134\u24aa\u24c4\u24de\u3375\u33c7\u33d2\u33d6\uff2f\uff4f]",
      P: "[Pp\u1d3e\u1d56\u1e54-\u1e57\u2119\u24ab\u24c5\u24df\u3250\u3371\u3376\u3380\u338a\u33a9-\u33ac\u33b0\u33b4\u33ba\u33cb\u33d7-\u33da\uff30\uff50]",
      Q: "[Qq\u211a\u24ac\u24c6\u24e0\u33c3\uff31\uff51]",
      R: "[Rr\u0154-\u0159\u0210-\u0213\u02b3\u1d3f\u1d63\u1e58-\u1e5b\u1e5e\u1e5f\u20a8\u211b-\u211d\u24ad\u24c7\u24e1\u32cd\u3374\u33ad-\u33af\u33da\u33db\uff32\uff52]",
      S: "[Ss\u015a-\u0161\u017f\u0218\u0219\u02e2\u1e60-\u1e63\u20a8\u2101\u2120\u24ae\u24c8\u24e2\u33a7\u33a8\u33ae-\u33b3\u33db\u33dc\ufb06\uff33\uff53]",
      T: "[Tt\u0162-\u0165\u021a\u021b\u1d40\u1d57\u1e6a-\u1e71\u1e97\u2121\u2122\u24af\u24c9\u24e3\u3250\u32cf\u3394\u33cf\ufb05\ufb06\uff34\uff54]",
      U: "[Uu\xd9-\xdc\xf9-\xfc\u0168-\u0173\u01af\u01b0\u01d3\u01d4\u0214-\u0217\u1d41\u1d58\u1d64\u1e72-\u1e77\u1ee4-\u1ee7\u2106\u24b0\u24ca\u24e4\u3373\u337a\uff35\uff55]",
      V: "[Vv\u1d5b\u1d65\u1e7c-\u1e7f\u2163-\u2167\u2173-\u2177\u24b1\u24cb\u24e5\u2c7d\u32ce\u3375\u33b4-\u33b9\u33dc\u33de\uff36\uff56]",
      W: "[Ww\u0174\u0175\u02b7\u1d42\u1e80-\u1e89\u1e98\u24b2\u24cc\u24e6\u33ba-\u33bf\u33dd\uff37\uff57]",
      X: "[Xx\u02e3\u1e8a-\u1e8d\u2093\u213b\u2168-\u216b\u2178-\u217b\u24b3\u24cd\u24e7\u33d3\uff38\uff58]",
      Y: "[Yy\xdd\xfd\xff\u0176-\u0178\u0232\u0233\u02b8\u1e8e\u1e8f\u1e99\u1ef2-\u1ef9\u24b4\u24ce\u24e8\u33c9\uff39\uff59]",
      Z: "[Zz\u0179-\u017e\u01f1-\u01f3\u1dbb\u1e90-\u1e95\u2124\u2128\u24b5\u24cf\u24e9\u3390-\u3394\uff3a\uff5a]",
    };

    // escape meta characters
    searchString = searchString.replace(/([|()[{.+*?^$\\])/gu, "\\$1");

    // split into words
    const words = searchString.split(/\s+/u);

    // sort by length
    const lengthComp = function (a, b) {
      return b.length - a.length;
    };
    words.sort(lengthComp);

    // replace characters by their compositors
    const accentReplacer = function (chr) {
      return accented[chr.toUpperCase()] || chr;
    };
    for (let i = 0; i < words.length; i++) {
      words[i] = words[i].replace(/\S/gu, accentReplacer);
    }

    // join as alternatives
    const regexp = words.join("|");
    return regexp;
  }
</script>

<div
  class="{className || ''}
  {hideArrow || !items.length ? 'hide-arrow' : ''}
  {multiple ? 'is-multiple' : ''} autocomplete select is-fullwidth {uniqueId}"
  class:show-clear={clearable}
  class:is-loading={showLoadingIndicator && loading}
  {@attach clickOutside(close)}
>
  <select name={selectName} id={selectId}>
    {#if !multiple && value}
      <option {value} selected>{text}</option>
    {:else if multiple && value}
      {#each value as i}
        <option value={i} selected>
          {getLabelForValue(i)}
        </option>
      {/each}
    {/if}
  </select>

  <div class="input-container">
    <input
      type="text"
      class="{inputClassName ||
        ''} input autocomplete-input read-only:text-gray-03 disabled:bg-gray-00"
      id={inputId}
      autocomplete={html5autocomplete ? "on" : "off"}
      placeholder={multiple && value.length ? placeholderMulti : placeholder}
      {name}
      {disabled}
      {title}
      readonly={readonly || (lock && value)}
      bind:this={input}
      bind:value={text}
      oninput={onInput}
      onfocus={onFocusInternal}
      {onblur}
      onkeydown={onKeyDown}
      onclick={onInputClick}
      onkeypress={onKeyPress}
      aria-describedby={formatErrors(name, errorMessages)}
    />
    {#if clearable && text?.length}
      <button onclick={clear} class="autocomplete-clear-button">&#10006;</button
      >
    {/if}
  </div>

  <div
    class="{dropdownClassName || ''} autocomplete-list is-fullwidth"
    class:hidden={!opened}
    bind:this={list}
  >
    {#if hasPrependSlot}
      {@render prepend?.()}
      <hr class:hidden={!showList} class="mx-s20" />
    {/if}

    <div class:hidden={!showList} class="py-s10 text-f14">
      {#if filteredListItems && filteredListItems.length > 0}
        {#each filteredListItems as listItem, i}
          {#if listItem && (maxItemsToShowInList <= 0 || i < maxItemsToShowInList)}
            {#if listItem}
              {@const confirmed =
                value &&
                (multiple
                  ? value.includes(listItem.value)
                  : listItem.value === value)}
              <button
                class="autocomplete-list-item px-s20 py-s6 flex w-full flex-row items-baseline text-left {i ===
                highlightIndex
                  ? 'selected'
                  : ''} {multiple ? 'gap-s10' : 'justify-between'}"
                class:confirmed
                onclick={(event) => {
                  event.preventDefault();
                  onListItemClick(listItem);
                }}
                onpointerenter={() => {
                  highlightIndex = i;
                }}
              >
                {#if multiple}
                  <CheckboxMark checked={confirmed} />
                {/if}

                {#if hasCustomContentSlot}
                  {@render itemContent?.({ item: listItem })}
                {:else}
                  <div>
                    {@html listItem.highlighted
                      ? listItem.highlighted.label
                      : listItem.label}
                  </div>
                {/if}

                {#if !multiple}
                  <div class="checkmark invisible grow-0">
                    <div class="ml-s8 h-s16 w-s24 fill-current">
                      {@html checkIcon}
                    </div>
                  </div>
                {/if}
              </button>
            {/if}
          {/if}
        {/each}

        {#if maxItemsToShowInList > 0 && filteredListItems.length > maxItemsToShowInList}
          <div class="autocomplete-list-item-no-results">
            ...{filteredListItems.length - maxItemsToShowInList} results not shown
          </div>
        {/if}
      {:else if loading && loadingText}
        <div class="autocomplete-list-item-loading">
          <span class="text-gray-text-alt">{loadingText}</span>
        </div>
      {:else if noResultsText}
        <div class="autocomplete-list-item-no-results">
          <span class="text-error">{noResultsText}</span>
        </div>
      {/if}
    </div>

    {#if hasAppendSlot}
      <hr class:hidden={!showList} class="mx-s20" />
      {@render append?.()}
    {/if}
  </div>
</div>
{#if multiple && value.length}
  <div class="tags-container">
    {#each value as tagItem}
      <div
        class="tags bg-magenta-brand text-f14 font-bold break-all text-white"
      >
        {getLabelForValue(tagItem)}

        {#if !disabled && !readonly && !isFixedItem(tagItem)}
          <button
            class="tag-delete"
            onclick={(event) => {
              event.preventDefault();
              unselectItem(tagItem);
            }}
          >
            {@html closeCircleIcon}
          </button>
        {/if}
      </div>
    {/each}
  </div>
{/if}
<svelte:window onclick={onDocumentClick} />

<style lang="postcss">
  @reference "../../../../app.css";

  .autocomplete {
    position: relative;
    display: inline-block;
    max-width: 100%;
    vertical-align: top;
  }

  .autocomplete:not(.hide-arrow):not(.is-loading)::after {
    position: absolute;
    z-index: 4;
    top: 50%;
    right: 1.125em;
    display: block;
    width: 0.625em;
    height: 0.625em;
    border: 3px solid transparent;
    border-color: #3273dc;
    border-top: 0;
    border-right: 0;
    margin-top: -0.4375em;
    border-radius: 2px;
    content: " ";
    pointer-events: none;
    -webkit-transform: rotate(-45deg);
    transform: rotate(-45deg);
    -webkit-transform-origin: center;
    transform-origin: center;
  }

  .autocomplete.show-clear:not(.hide-arrow)::after {
    right: 2.3em;
  }

  .autocomplete * {
    box-sizing: border-box;
  }

  .autocomplete-input {
    width: 100%;
    height: 100%;
    padding: 12px;
    font: inherit;
  }

  .autocomplete:not(.hide-arrow) .autocomplete-input {
    padding-right: 2em;
  }

  .autocomplete.show-clear:not(.hide-arrow) .autocomplete-input {
    padding-right: 3.2em;
  }

  .autocomplete.hide-arrow.show-clear .autocomplete-input {
    padding-right: 2em;
  }

  .autocomplete-list {
    position: absolute;
    z-index: 99;
    top: 20px;
    width: 100%;
    max-height: calc(15 * (1rem + 10px) + 15px);
    background: #fff;
    overflow-y: auto;
    user-select: none;
  }

  .autocomplete-list-item {
    color: var(--col-text);
    cursor: pointer;
    line-height: 1.25;
  }

  .autocomplete-list-item.confirmed {
    background-color: white;
    color: var(--col-magenta-cta);
  }

  .autocomplete-list-item.confirmed .checkmark {
    visibility: visible;
  }

  .autocomplete-list-item.selected {
    background-color: var(--col-gray-bg);
    color: var(--col-text);
  }

  .autocomplete-list-item.selected.confirmed {
    background-color: var(--col-gray-bg);
    color: var(--col-magenta-cta);
  }

  .autocomplete-list-item-no-results {
    padding: 5px 15px;
    color: #999;
    line-height: 1;
  }

  .autocomplete-list-item-loading {
    padding: 5px 15px;
    line-height: 1;
  }

  .autocomplete-list.hidden {
    display: none;
  }

  .autocomplete.show-clear .autocomplete-clear-button {
    position: absolute;
    z-index: 4;
    top: 50%;
    right: 0.1em;
    display: block;
    padding: 0.3em 0.6em;
    cursor: pointer;
    text-align: center;
    -webkit-transform: translateY(-50%);
    -ms-transform: translateY(-50%);
    transform: translateY(-50%);
  }

  .autocomplete:not(.show-clear) .autocomplete-clear-button {
    display: none;
  }

  .autocomplete select {
    display: none;
  }

  .tags-container {
    @apply mt-s12 gap-s8 flex flex-row flex-wrap;
  }

  .tags {
    display: flex;
    flex-direction: row;
    border-radius: var(--spacing-s4);
    padding: var(--spacing-s2) var(--spacing-s8);
  }

  .tag-delete {
    position: relative;
    top: 2px;
    margin-left: 4px;
    cursor: pointer;
    fill: currentColor;
    width: var(--spacing-s16);
    height: var(--spacing-s16);
    shrink: 0;
  }
</style>
